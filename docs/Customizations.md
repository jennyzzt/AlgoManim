# Customizations

## Adding Customizations I
### Preconfigurations
There are many types of customizations that can be added to the default animation generated by the library. The easiest of which are `global` customizations which can be applied to all animations before the `algoconstruct()` begins. These customizations are added by overriding the `preconfig(self, settings)` method and changing the values directly on the dictionary as seen below.  

```python
from manimlib.imports import *
from algomanim.algoscene import AlgoScene
from algomanim.algolist import AlgoList
from algomanim.settings import Shape

class DefaultBubbleSortScene(AlgoScene):
    def preconfig(self, settings):
        settings['font_color'] = BLACK
        settings['highlight_color'] = "#e74c3c" # red
        settings['node_color'] = PURPLE
        settings['node_shape'] = Shape.CIRCLE
        settings['node_size'] = 0.5
    
    ...
```

## Adding Customizations II
### Programmatic AlgoManim configurations
While your algorithm executes in `algocons`, the library compiles a list of manim animations `action_pairs` which are then rendered after the algorithm finishes into a video. This allows you to then directly edit the animations generated by us. We provide a programmatic way of configuring these `action_pairs` by overriding the `customize(self, action_pairs)` method.  
  
The types of customizations you can make here are:
- timeline changes (`fast_forward`, `skip`)
- change colors of specific animations (to emphasize edge-cases for example) (`set_color`)
- add new animations
  - pause (`add_wait`)
  - fade out all items on screen (`add_fade_out_all`)
  - fade in all items on screen (`add_fade_in_all`)
  - add text to screen (`add_text`)
  - change text on screen (`change_text`)
  - remove text from screen (`remove_text`)

You can see this happening in the code snippet given below:
```python
...
class DefaultBubbleSortScene(AlgoScene):
    ...
    def customize(self, action_pairs):
        # 1) color of highlight is changed for first iteration of algorithm
        highlight_pairs = self.find_action_pairs(
            method='compare', occurence=1, lower_level='highlight')

        for action_pair in highlight_pairs:
            action_pair.set_color('#ff6666') # pylint: disable=E0602

        # 2) all animations till the 10th iteration of compare
        # are fast forwarded (2x speed)
        compare_pair = self.find_action_pairs(
            method='compare', occurence=10
        )[0]
        compare_index = compare_pair.get_index()
        self.fast_forward(0, compare_index - 1)

        # 3) Add Custom Transforms into the list to be rendered in runtime
        self.add_fade_out_all(compare_index)

        # 4) insert a wait between iterations
        self.add_wait(compare_index + 1)

        # 5) skip remaining animations from third iteration till the end
        self.skip(compare_index + 2)

        self.add_fade_in_all(len(action_pairs))
```
### Introducing your own Manim animations
If you want to take the extra step and introduce your own animations from the [Manim library](https://github.com/3b1b/manim),
you can use `AlgoScene`'s `add_transform` method in `def customize(self, action_pairs):`.

The basic idea is to append a new custom animation to an `action_pair`. 
This is so that it gets animated with the rest of the animations in that `action_pair`.
To achieve this, we have `add_transform(action_pair_index, transform)`.
1. `action_pair_index` identifies the action_pair to append the new animation onto.
2. `transform` identifies the Manim transformation to execute.
3. Make sure to wrap the transform in a **lambda** so that the animation is not executed immediately.


Here is a sample code snippet to add custom transforms:
```python
...
    
    # I want to add custom manim text in the action_pair with index=idx,
    # then change it to another text in the action_pair with index=idx2 using Manim's animations
    def customize(self, action_pairs):
        ...
        ...

        # Adding the text
        title_text = TextMobject("My custom text")
        title_text.to_edge(UP)
        transform = lambda: Write(title_text)
        self.add_transform(idx, transform)

        
        # Changing the text
        new_text = TextMobject("My custom text with Manim's replacement transform animation")
        new_text.to_edge(UP)
        transform = lambda: [FadeOut(title_text), ReplacementTransform(title_text, new_text)]
        self.add_transform(idx2, transform)
        
        ...

```


### Finding Indices
As you have seen above, the customization functions require you to provide an index in the list. A helper function (`find_action_pairs`) has been provided for your convenience so that you are able to edit the animations which you would like to by specifying the method that the animation was generated by. This can be seen in the line `self.find_action_pairs(method='compare', occurence=1, lower_level='highlight')` which finds the animations generated when `compare` was called for the 1st time. In fact we are able to specify the specific animation inside `compare`, `highlight` that we want to edit.  

Please note that these names and numbers can be identified by inspecting the timeline in the GUI. 

## Adding Customizations III
### Pinning framework
To add more customisability, we have introduced a pinning framework that allows you to insert static `action_pairs`- action_pairs with no animations - in between other action_pairs.
This allows you to do various things:
1. Introduce markers which shows which part of the algorithm is being executed in the GUI
2. Add non-static animations at these pins later in `customize(self, action_pairs)`.
3. Change animations of `action_pairs` around these pins in `customize(self, action_pairs)`.

### Adding Pins to your algorithm
```python
\\ Binary Tree Sort Algorithm

    def algo(self):
        unsorted_list = [25, 43, 5, 18, 30, 3, 50]
        algolist = AlgoList(self, unsorted_list, displacement=UP)
        self.insert_pin("list_elems", *algolist.nodes)

        self.insert_pin("inserted_node", algolist.nodes[0])
        root = AlgoBinaryTreeNode(self, algolist.nodes[0].val)
        algotree = AlgoBinaryTree(self, 3, root)
        for node in algolist.nodes[1:]:
            self.insert_pin("inserted_node", node)
            algotree.insert(node.val)

        self.insert_pin("finished_tree_build")
        sorted_list = AlgoList(self, [], displacement=3.5 * DOWN)
        self.inorder_traversal(root, sorted_list)
```

### Customising using pins
```python
    # Customising the Binary Tree Sort Algorithm
    def customize(self, action_pairs):
    
        # 3. Change animations of `action_pairs` around these pins
        # Add text straight after the "list_elems" pin 
        pin = self.find_pin("list_elems")[0]
        idx = pin.get_index()

        title_text = TextMobject("First, we insert the elements of the list into a binary tree")
        title_text.to_edge(UP)
        transform = lambda: Write(title_text)
        self.add_transform(idx, transform)

        self.add_wait(idx + 1, wait_time = 0.25)
        
        # 2. Add non-static animations at these pins
        # Highlight the arguments passed to the pin "inserted_node"
        self.chain_pin_highlight("inserted_node")

        # 3. Change animations of `action_pairs` around these pins
        # Add text 2 animations after the "finished_tree_build" pin 
        tree_finished_pin = self.find_pin("finished_tree_build")[0]
        idx2 = tree_finished_pin.get_index()
        self.fast_forward(idx + 2, idx2)
        new_text = TextMobject("Now, we do an INORDER traversal of the tree")
        new_text.to_edge(UP)
        transform = lambda: [FadeOut(title_text), ReplacementTransform(title_text, new_text)]
        self.add_transform(idx2, transform)


        # 2. Add non-static animations at these pins
        # Highlight the arguments passed to the pin "visited_node"
        self.chain_pin_highlight("visited_node")
    

        # 3. Change animations of `action_pairs` around these pins
        # Add text straight after the "finished_tree_build" pin 
        self.fast_forward(idx2 + 1)
        end_text = TextMobject("We have a sorted list!")
        end_text.to_edge(UP)
        transform = lambda: [FadeOut(new_text), ReplacementTransform(new_text, end_text)]
        self.add_transform(None, transform)
```

### Utility functions
Here are some of the pre-defined utility functions that you can use:
- Insert a pin in your algorithm, acceps a variable list argument
  which can be used later on (`insert_pin`)
- Find all `action_pairs` from a pin (`find_pin`)
- all of the utility customisations in **Adding Customizations II**
- utilities that affect ALL pins with the specified name
    - introduce highlighting (`chain_pin_highlight`)

## Adding Customizations IV
### Adding text

For any `AlgoObject` like `AlgoNode`, `AlgoList`, `AlgoBinaryTree`, we can generate text animations by using the `add_text(text, key, vector=UP)` function. 
1. The `text` parameter indicates the text that will be shown
2. The `key` parameter indicates the key for the specific text in the scene.
If the key already exists, i.e. text has been generated with that key, then the old text  is hidden and the new text is shown.
3. The `vector` parameter indicates where the text will appear relative to the `AlgoObject`. By default, `vector=UP`.

Functions that have in-built text:
 - `AlgoList`'s `compare` method which can be triggered with `compare(..,text=true)`.