# Customizations

## Adding Customizations I
### Preconfigurations
There are many types of customizations that can be added to the default animation generated by the library. The easiest of which are `global` customizations which can be applied to all animations before the `algo()` begins. These customizations are added by overriding the `preconfig(self, settings)` method and changing the values directly on the dictionary as seen below.  

```python
from manimlib.imports import *
from algomanim.algoscene import AlgoScene
from algomanim.algolist import AlgoList

class DefaultBubbleSortScene(AlgoScene):
    def preconfig(self, settings):
        settings['font_color'] = BLACK
        settings['highlight_color'] = "#e74c3c" # red
        settings['node_color'] = PURPLE
        settings['node_shape'] = 'circle'
        settings['node_size'] = 0.5
        settings['code_anim'] = True # show code alongside the animation
    ...
```

## Adding Customizations II
### Programmatic AlgoManim configurations
While your algorithm executes in `algo`, the library compiles a list of manim animations `action_pairs` which are then rendered after the algorithm finishes into a video. This allows you to then directly edit the animations generated by us. We provide a programmatic way of configuring these `action_pairs` by overriding the `customize(self, action_pairs)` method.  
  
The types of customizations you can make here are:
- timeline changes (`fast_forward`, `skip`)
- change colors of specific animations (to emphasize edge-cases for example) (`set_color`)
- add new animations
  - pause (`add_wait`)
  - fade out all items on screen (`add_fade_out_all`)
  - fade in all items on screen (`add_fade_in_all`)
  - add text to screen (`add_text`)
  - change text on screen (`change_text`)
  - remove text from screen (`remove_text`)

You can see this happening in the code snippet given below:
```python
...
class DefaultBubbleSortScene(AlgoScene):
    ...
    def customize(self, action_pairs):
        # 1) color of highlight is changed for first iteration of algorithm
        highlight_pairs = self.find_action_pairs(
            method='compare', occurence=1, lower_level='highlight')

        for action_pair in highlight_pairs:
            action_pair.set_color('#ff6666') # pylint: disable=E0602

        # 2) all animations till the 10th iteration of compare
        # are fast forwarded (2x speed)
        compare_pair = self.find_action_pairs(
            method='compare', occurence=10
        )[0]
        compare_index = compare_pair.get_index()
        self.fast_forward(0, compare_index - 1)

        # 3) Add Custom Transforms into the list to be rendered in runtime
        self.add_fade_out_all(compare_index)

        # 4) insert a wait between iterations
        self.add_wait(compare_index + 1)

        # 5) skip remaining animations from third iteration till the end
        self.skip(compare_index + 2)

        self.add_fade_in_all(len(action_pairs))
```
### Custom Animations
If you want to take the extra step and introduce your own animations from the [Manim library](https://github.com/3b1b/manim),
you can use `AlgoScene`'s `add_transform` method in `def customize(self, action_pairs):`.

The basic idea is to provide a `transform` that we will execute later.
A `transform` is simply a function that is executed in between the rendering of animations. It can take in any number of arguments but must return a list of `manim` Transforms (`FadeOut`, `FadeIn`, `ApplyMethod`, `GrowFromCenter`, `ScaleInPlace`, etc. - an entire list can be found in the `manim`  source code) that will be played (through the `scene.play` method). This is so that it gets animated with the rest of the animations.

To achieve this, we have the utility function `add_transform(action_pair_index, transform)`.
1. `action_pair_index` identifies the action_pair to append the new animation onto.
2. `transform` identifies the Manim transformation to execute.
3. Make sure to wrap the transform in a **lambda** so that the animation is not executed immediately.

Here is a sample code snippet to add custom transforms:
```python
...
    
    # I want to add custom manim text in the action_pair with index=idx,
    # then change it to another text in the action_pair with index=idx2 using Manim's animations
    def customize(self, action_pairs):
        ...
        ...

        # Adding the text
        title_text = self.add_text("Custom Text", idx, text_position)

        ...
        
        # Emphasizing the text
        emphasize = lambda text: [ScaleInPlace(text, 2, rate_func = wiggle)]
        self.add_transform(idx2, emphasize, [title_text])
        
        ...

```


### Finding Indices
As you have seen above, the customization functions require you to provide an index in the list. A helper function (`find_action_pairs`) has been provided for your convenience so that you are able to edit the animations which you would like to by specifying the method that the animation was generated by. This can be seen in the line `self.find_action_pairs(method='compare', occurence=1, lower_level='highlight')` which finds the animations generated when `compare` was called for the 1st time. In fact we are able to specify the specific animation inside `compare`, `highlight` that we want to edit.  

Please note that these names and numbers can be identified by inspecting the timeline in the GUI. 

## Adding Customizations III
### Pinning framework
To add more customisability, we have introduced a pinning framework that allows you to insert your own custom animations (`transforms`) in between other animations.
This allows you to do various things:
1. Introduce markers which shows which part of the algorithm is being executed in the GUI
2. Add custom animations at these pins later in `customize(self, action_pairs)`.
3. Change default animations (`action_pairs`) around these pins in `customize(self, action_pairs)`.

### Adding Pins to Your Algorithm
```python
# Binary Tree Sort Algorithm

    def algo(self):
        unsorted_list = [25, 43, 5, 18, 30, 3, 50]
        algolist = AlgoList(self, unsorted_list, displacement=UP)
        self.insert_pin("list_elems", *algolist.nodes)

        self.insert_pin("inserted_node", algolist.nodes[0])
        root = AlgoBinaryTreeNode(self, algolist.nodes[0].val)
        algotree = AlgoBinaryTree(self, 3, root)
        for node in algolist.nodes[1:]:
            self.insert_pin("inserted_node", node)
            algotree.insert(node.val)

        self.insert_pin("finished_tree_build")
        sorted_list = AlgoList(self, [], displacement=3.5 * DOWN)
        self.inorder_traversal(root, sorted_list)
```

### Customising Using Pins
```python
    # Customising the Binary Tree Sort Algorithm
    def customize(self, action_pairs):
    
        # 3. Change animations of `action_pairs` around these pins
        # Add text straight after the "list_elems" pin 
        pin = self.find_pin("list_elems")[0]
        idx = pin.get_index()

        title_text = self.add_text("First, we insert the elements of the list \
            into a binary tree", idx, text_position)

        self.add_wait(idx + 1, wait_time = 0.25)
        
        # 2. Add custom animations at these pins
        # Highlight the arguments passed to the pin "inserted_node"
        self.chain_pin_highlight("inserted_node")

        # 3. Change animations of `action_pairs` around these pins
        # Add text 2 animations after the "finished_tree_build" pin 
        tree_finished_pin = self.find_pin("finished_tree_build")[0]
        idx2 = tree_finished_pin.get_index()
        self.fast_forward(idx + 2, idx2)
        title_text = self.change_text("Now, we do an INORDER traversal of the tree",
            title_text, idx2)


        # 2. Add custom animations at these pins
        # Highlight the arguments passed to the pin "visited_node"
        self.chain_pin_highlight("visited_node")
    

        # 3. Change default animations around these pins
        # Add text straight after the "finished_tree_build" pin 
        self.fast_forward(idx2 + 1)
        self.change_text("We have a sorted list!", title_text)
    
    def chain_pin_highlight(self, pin_str):
        pins = self.find_pin(pin_str)
        prev_node = None
        node_highlight = lambda node: \
            [ApplyMethod(node.node.set_fill, self.settings['highlight_color'])]
        node_dehighlight = lambda node: \
            [ApplyMethod(node.node.set_fill, self.settings['node_color'])]
        for pin in pins:
            node = pin.get_args()[0]
            self.add_transform(pin.get_index(), node_highlight, [node])
            if prev_node is not None:
                self.add_transform(pin.get_index() + 1, node_dehighlight, [prev_node])
            prev_node = node
```

### Utility Functions
Here are some of the pre-defined utility functions that you can use:
- Insert a pin in your algorithm, acceps a variable list argument
  which can be used later on (`insert_pin`)
- Retrieve all pins and their corresponding arguments (`find_pin`)
- Extract index of where pin was placed (`get_index`)
- Extract arguments passed into `insert_pin` (`get_args`)
- All of the utility customisations in **Adding Customizations II**

## Adding Customizations IV
### Attaching Text to Objects

For any `AlgoObject` like `AlgoNode`, `AlgoList`, `AlgoBinaryTree`, we can generate text animations by using the `add_text(text, key, vector=UP)` function. 
1. The `text` parameter indicates the text that will be shown
2. The `key` parameter indicates the key for the specific text in the scene.
If the key already exists, i.e. text has been generated with that key, then the old text  is hidden and the new text is shown.
3. The `vector` parameter indicates where the text will appear relative to the `AlgoObject`. By default, `vector=UP`.

Functions that have in-built text:
 - `AlgoList`'s `compare` method which can be triggered with `compare(..,text=true)`.